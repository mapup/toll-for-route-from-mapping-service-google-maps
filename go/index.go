package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"time"
)

type Polyline struct {
	Points string `json:"points"`
}

type LatLng struct {
	Lat float64 `json:"lat"`
	Lng float64 `json:"lng"`
	// The latitude in degrees. It must be in the range [-90.0, +90.0].

}

const (
	source      string = "Dallas,TX"
	destination string = "CentralSquare,NY"
)

type AutoGenerated struct {
	Routes []struct {
		Legs []struct {
			Steps []struct {
				Polyline struct {
					Points string `json:"points"`
				} `json:"polyline"`
			}
		}
	}
}

func main() {
	token := os.Getenv("Gmap_key")
	token_tollguru := os.Getenv("Tollgurukey")

	url := fmt.Sprintf("https://maps.googleapis.com/maps/api/directions/json?origin=%s&destination=%s&key=%s", source, destination, token)
	//fmt.Println(url)
	spaceClient := http.Client{
		Timeout: time.Second * 60, // Timeout after 60 seconds
	}

	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		log.Fatal(err)
	}

	req.Header.Set("User-Agent", "spacecount-tutorial")

	res, getErr := spaceClient.Do(req)
	if getErr != nil {
		log.Fatal(getErr)
	}

	if res.Body != nil {
		defer res.Body.Close()
	}

	body, readErr := ioutil.ReadAll(res.Body)
	if readErr != nil {
		log.Fatal(readErr)
	}
	var polyline AutoGenerated

	jsonErr := json.Unmarshal(body, &polyline)
	if jsonErr != nil {
		log.Fatal(polyline)
	}

	points := make([]string, len(polyline.Routes[0].Legs[0].Steps))
	polyline_decoded := make([][]LatLng, len(polyline.Routes[0].Legs[0].Steps))
	polyline_encoded := []LatLng{}

	for i := range polyline.Routes[0].Legs[0].Steps {
		points[i] = polyline.Routes[0].Legs[0].Steps[i].Polyline.Points
		polyline_decoded[i] = DecodePolyline(points[i])

		polyline_encoded = append(polyline_encoded, DecodePolyline(points[i])...)
	}

	polyline_final := Encode(polyline_encoded)

	// Tollguru API request

	url_tollguru := "https://apis.tollguru.com/toll/v2/complete-polyline-from-mapping-service"

	requestBody, err := json.Marshal(map[string]string{
		"source":         "google",
		"polyline":       polyline_final,
		"vehicleType":    "2AxlesAuto",
		"departure_time": "2021-01-05T09:46:08Z",
	})

	request, err := http.NewRequest("POST", url_tollguru, bytes.NewBuffer(requestBody))
	request.Header.Set("x-api-key", token_tollguru)
	request.Header.Set("Content-Type", "application/json")

	client := &http.Client{
		Timeout: time.Second * 60,
	}
	resp, err := client.Do(request)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	body, error := ioutil.ReadAll(resp.Body)
	if error != nil {
		log.Fatal(err)
	}

	var cost map[string]interface{}
	jsonEr := json.Unmarshal([]byte(body), &cost)
	if jsonEr != nil {
		log.Fatal(cost)
	}

	toll := cost["route"].(map[string]interface{})["costs"].(map[string]interface{})["tag"]
	fmt.Printf("The toll rate is: %v", toll)

}
func DecodePolyline(poly string) []LatLng {
	p := &Polyline{
		Points: poly,
	}
	return p.Decode()
}

// Decode converts this encoded Polyline to an array of LatLng objects.
func (p *Polyline) Decode() []LatLng {
	input := bytes.NewBufferString(p.Points)

	var lat, lng int64
	path := make([]LatLng, 0, len(p.Points)/2)
	for {
		dlat, _ := decodeInt(input)
		dlng, err := decodeInt(input)
		if err == io.EOF {
			return path
		}

		lat, lng = lat+dlat, lng+dlng
		path = append(path, LatLng{
			Lat: float64(lat) * 1e-5,
			Lng: float64(lng) * 1e-5,
		})
	}
}

// Encode returns a new encoded Polyline from the given path.
func Encode(path []LatLng) string {
	var prevLat, prevLng int64

	out := new(bytes.Buffer)
	out.Grow(len(path) * 4)

	for _, point := range path {
		lat := int64(point.Lat * 1e5)
		lng := int64(point.Lng * 1e5)

		encodeInt(lat-prevLat, out)
		encodeInt(lng-prevLng, out)

		prevLat, prevLng = lat, lng
	}

	return out.String()
}

// decodeInt reads an encoded int64 from the passed io.ByteReader.
func decodeInt(r io.ByteReader) (int64, error) {
	result := int64(0)
	var shift uint8

	for {
		raw, err := r.ReadByte()
		if err != nil {
			return 0, err
		}

		b := raw - 63
		result += int64(b&0x1f) << shift
		shift += 5

		if b < 0x20 {
			bit := result & 1
			result >>= 1
			if bit != 0 {
				result = ^result
			}
			return result, nil
		}
	}
}

// encodeInt writes an encoded int64 to the passed io.ByteWriter.
func encodeInt(v int64, w io.ByteWriter) {
	if v < 0 {
		v = ^(v << 1)
	} else {
		v <<= 1
	}
	for v >= 0x20 {
		w.WriteByte((0x20 | (byte(v) & 0x1f)) + 63)
		v >>= 5
	}
	w.WriteByte(byte(v) + 63)
}
